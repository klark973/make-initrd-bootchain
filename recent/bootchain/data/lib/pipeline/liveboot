#!/bin/bash -efu

. altboot-sh-functions

check_parameter ALTBOOT_LIVEBOOT

# You can change defaults in /etc/sysconfig/altboot
OEM_NFS_NETINST="${OEM_NFS_NETINST:-/srv/public/netinst}"
OEM_CIFS_NETINST="${OEM_CIFS_NETINST:-/netinst}"
OEM_OVERLAYS_DIR="${OEM_OVERLAYS_DIR:-/tmp/overlays}"
OEM_NETIMGS_BASE="${OEM_NETIMGS_BASE:-/tmp/images}"
OEM_LIVE_STORAGE="${OEM_LIVE_STORAGE-}"
OEM_BAD_STORAGE="${OEM_BAD_STORAGE-}"

need_overlay=1
livecd_overlays=
live_rw=

b_a()
{
	get_bootarg LIVEBOOT $1
}

b_a stagename
b_a method
b_a directory
b_a overlayroot
b_a profile
b_a overlays
b_a flags
b_a timeout


local_slice()
{
	[ "$flags" != "${flags//*local_profile*/}" ] &&
	[ -n "$profile" ] && [ -n "$overlays" ] &&
	[ -L "/dev/disk/by-label/$overlays" ] ||
		return
	enter "local_slice"

	local mnt=
	local devname="$(readlink-e "/dev/disk/by-label/$overlays")"
	local mp="$(grep -s "$devname /" /proc/mounts |cut -f2 -d' ')"

	if mountpoint -q -- "$mp"; then
		message "device '$overlays' ($devname) already mounted to $mp"
	else
		mp="${prevdir}${OEM_NETIMGS_BASE}"

		run mkdir -p -- "$mp"

		if ! run mount -o ro -- "$devname" "$mp"; then
			message "can't mount device, specified by 'overlays'"
			leave "local_slice"
			return
		fi

		message "device '$overlays' ($devname) has mounted successfully"
		mnt=1
	fi

	local img="$directory/$profile.squashfs"

	if [ ! -r "${mp}${img}" ]; then
		message "however specified by profile overlay not found: '$img'"
		[ -z "$mnt" ] || run umount -fl -- "$mp" ||:
	else
		local imgdir="${prevdir}${OEM_OVERLAYS_DIR}"

		run mkdir -p -- "$imgdir"

		if run mount -t squashfs -o ro,loop -- "${mp}${img}" "$imgdir"; then
			message "using overlay from local profile: '$img'"
			livecd_overlays="$imgdir:"
		else
			message "overlay was damaged: '$img'"
			run rmdir -- "$imgdir" ||:
		fi
	fi

	leave "local_slice"
}

mount_overlays()
{
	enter "mount_overlays"

	local msg= dirp="$1"
	local img images imgdir

	run ls -l -- "$dirp/" >/dev/null 2>&1 ||:
	images="$(run find "$dirp/$profile" -maxdepth 1 -type f \
			-name '*.iso' -o -name '*.squashfs' |sort)"

	for img in $images _; do
		[ -r "$img" ] ||
			continue
		imgdir="${prevdir}${OEM_OVERLAYS_DIR}/${img##*/}"

		run mkdir -p -- "$imgdir"

		if run mount -o ro,loop -- "$img" "$imgdir"; then
			livecd_overlays="$imgdir:$livecd_overlays"
			msg="${msg:+$msg }${img##*/}"
		fi
	done

	[ -n "$msg" ] && msg="overlays found: $msg" ||
		msg="no overlays found for profile '$profile'"
	message "$msg"

	leave "mount_overlays"
}

nfs_slice()
{
	enter "nfs_slice"

	local server="$(stage2_getenv HOST)"
	local dirp="$(stage2_getenv PREFIX)"

	[ -n "$dirp" ] || dirp="$directory"

	local parentdir="${dirp%/?*}"
	local opts="${NFSOPTS:-soft,nolock,retrans=10}"
	local mp="${prevdir}${OEM_NETIMGS_BASE}"

	# Fallback: if HOST has not exported to the stage2
	if [ -z "$server" ]; then
		message "detecting IP-address of the connected NFS-server"
		server="$(run ss -n -o state established '( dport = :2049 )' |
				sed '2!d;s/  */ /g' |
				cut -f5 -d' ' |
				cut -f1 -d:)"
		if [ -z "$server" ]; then
			message "NFS-server not found"
			leave "nfs_slice"
			return
		fi
	fi

	[ -n "$overlays" ] ||
		overlays="${parentdir:-$OEM_NFS_NETINST}/overlays-live"
	message "mounting NFS overlays from $server:$overlays"

	run mkdir -p -- "$mp"

	if run mount.nfs "$server:$overlays" "$mp" -r -o "$opts"; then
		debug "$server:$overlays has mounted to $mp"
	else
		message "NFS mount failed"
		leave "nfs_slice"
		return
	fi

	mount_overlays "$mp"

	leave "nfs_slice"
}

cifs_slice()
{
	enter "cifs_slice"

	: # TODO: ...

	leave "cifs_slice"
}

livecd_slice()
{
	enter "livecd_slice"

	case "$method" in
	disk|cdrom|'')
		local_slice
		;;
	nfs)
		nfs_slice
		;;
	cifs)
		cifs_slice
		;;
	esac

	leave "livecd_slice"
}

create_disk_slice()
{
	enter "create_disk_slice"

	local devname="$(stage2_getenv DEVICE)"

	# Fallback: if DEVICE has not exported to the stage2
	if [ -z "$devname" -a -n "$OEM_CDIMAGE_PATH" ]; then
		devname="$(mountpoint -d -- "$OEM_CDIMAGE_PATH" ||:)"
		devname="/sys/dev/block/$devname/uevent"
		[ ! -f "$devname" ] && devname="" ||
			devname="$(grep -sE '^DEVNAME=' "$devname" |cut -f2- -d=)"
	fi
	if [ -z "$devname" -o ! -b "/dev/$devname" ]; then
		message "stage2-compatible live-rw boot media not found"
		leave "create_disk_slice"
		return
	fi

	local tmpf devpath partn whole=

	# if DEVICE is a partition, search a parent whole disk drive
	devpath="/sys/dev/block/$(mountpoint -x -- "/dev/$devname")"

	if [ -r "$devpath/partition" ]; then
		read -r partn <"$devpath/partition" ||
			partn=
		if [ -n "$partn" ]; then
			case "$devname" in
			*[0-9]p$partn)
				whole="${devname%%p$partn}"
				;;
			*$partn)
				whole="${devname%%$partn}"
				;;
			esac
		fi
	fi

	[ -n "$whole" ] && [ -b "/dev/$whole" ] &&
	[ -r "/sys/block/$whole/$devname/dev" ] ||
		whole="$devname"

	# Check for DEVICE is not read-only
	devpath="/sys/dev/block/$(mountpoint -x -- "/dev/$whole")"
	[ -r "$devpath/ro" ] && read -r partn <"$devpath/ro" || partn=0

	if [ "$partn" != 0 ]; then
		message "/dev/$whole is read-only, partitions appending is inpossible"
		leave "create_disk_slice"
		return
	fi

	# Check for unpartitioned space is 1 GiB or above
	message "checking unpartitioned space on the drive /dev/$whole"
	partn="$(LC_ALL=C run sfdisk -F -- "/dev/$whole" |head -n1 |cut -f6 -d' ')"
	debug "unpartitioned space on /dev/$whole: $partn bytes"

	if [ "$partn" -lt 1073741824 ]; then
		message "not enough space to create new R/W-partition"
		leave "create_disk_slice"
		return
	fi

	# Try to create a new partition
	message "creating a new partition on the drive /dev/$whole"
	tmpf="$(mktemp -t)"
	echo "," |LC_ALL=C run sfdisk -f -a -- "/dev/$whole" >"$tmpf" 2>&1 ||:
	devname="$(grep -s ": Created a new partition " "$tmpf" |cut -f1 -d:)"
	rm -f -- "$tmpf"

	# On success only
	if [ -n "$devname" ]
	then
		# Tell kernel about changes
		{ partn=partprobe
		  command -v $partn &&
			$partn "/dev/$whole" ||
			blockdev --rereadpt "/dev/$whole" ||:
		} >/dev/null 2>&1

		partn=0

		# Wait until kernel re-read partitions table
		while [ "$partn" -lt "$timeout" ]; do
			[ ! -b "$devname" ] ||
				break
			partn=$((1 + $partn))
			sleep 1
		done
	fi

	# On fail only
	if [ ! -b "$devname" ]; then
		message "can't create a new partition on the drive /dev/$whole"
		leave "create_disk_slice"
		return
	fi

	# Format a new partition
	message "creating filesystem on $devname"

	local opts="-t ext4 -O ^has_journal,sparse_super2"
	opts="$opts -E packed_meta_blocks=1,num_backup_sb=1"

	if run mke2fs $opts -L "$OEM_LIVE_STORAGE" -- "$devname" 1>&2; then
		debug "in create_disk_slice(): mke2fs success"

		while [ ! -L "/dev/disk/by-label/$OEM_LIVE_STORAGE" ]; do
			sleep 0.5
		done
	else
		debug "in create_disk_slice(): mke2fs failed (rc=$?)"

		run e2label "$devname" "$OEM_BAD_STORAGE" 1>&2 ||
			run wipefs -q -a -- "$devname" 1>&2 ||:
		run rm -f -- "/dev/disk/by-label/$OEM_LIVE_STORAGE"
	fi

	leave "create_disk_slice"
}

mount_disk_slice()
{
	enter "mount_disk_slice"

	local dev="$(readlink-e "$1")"
	local opts="noatime,nodiratime,barrier=0"
	opts="$opts,delalloc,nobh,errors=remount-ro"

	[ ! -b "$dev" ] ||
		run mount -o "$opts" -- "$dev" "$prevdir.rw"

	leave "mount_disk_slice"
}

disk_slice()
{
	enter "disk_slice"

	local live="/dev/disk/by-label/$OEM_LIVE_STORAGE"
	local bad="/dev/disk/by-label/$OEM_BAD_STORAGE"

	case "$method" in
	disk|cdrom)
		[ -L "$live" ] || [ -L "$bad" ] ||
			create_disk_slice

		if [ -L "$live" ]; then
			mountpoint -q -- "$prevdir.rw" ||
				mount_disk_slice "$live"
		fi
		;;

	'')
		if [ -n "$overlayroot" ] && [ -b "$live_rw" ]; then
			mountpoint -q -- "$prevdir.rw" ||
				mount_disk_slice "$live_rw"
		fi
		;;
	esac

	leave "disk_slice"
}

do_overlay()
{
	enter "do_overlay"

	local opts="$prevdir.ro"
	opts="$opts,upperdir=$prevdir.rw/rw"
	opts="$opts,workdir=$prevdir.rw/wk"

	message "remounting / with overlayfs"

	run mkdir -p -- "$prevdir.rw" "$prevdir.ro"
	[ -z "$live_rw" ] ||
		disk_slice
	mountpoint -q -- "$prevdir.rw" ||
		run mount -t tmpfs -o mode=755 -- none "$prevdir.rw"
	run mkdir -p -- "$prevdir.rw/rw" "$prevdir.rw/wk"
	run mount --move -- "$prevdir" "$prevdir.ro"
	[ "$stagename" != "live" ] ||
		livecd_slice
	opts="lowerdir=${livecd_overlays}${opts}"
	run mount -t overlay -o "$opts" -- overlay "$prevdir"
	run mkdir -p -- "$prevdir/.ro" "$prevdir/.rw"
	run mount --move -- "$prevdir.ro" "$prevdir/.ro"
	run mount --move -- "$prevdir.rw" "$prevdir/.rw"
	run rmdir -- "$prevdir.rw" "$prevdir.ro"

	message "rootfs overlayed with overlayfs"

	[ ! -r /etc/resolv.conf -o ! -d "$prevdir/etc" ] ||
		run cp -Lf -- /etc/resolv.conf "$prevdir/etc/"

	if [ -n "$OEM_CDIMAGE_PATH" ] &&
		mountpoint -q -- "$OEM_CDIMAGE_PATH"
	then
		run mkdir -p -- "${prevdir}${OEM_CDIMAGE_PATH}"
		run mount --move -- "$OEM_CDIMAGE_PATH" "${prevdir}${OEM_CDIMAGE_PATH}"
	fi

	passthru_results "$prevdir"

	leave "do_overlay"
}

run_in_interactive()
{
	IM_on
	IM_ponder_start "[ Preparing to stage2... ]"

	# Explicitly implying cancellation `set -e' option
	# inside do_overlay() and everything that is nested
	#
	do_overlay ||:

	IM_ponder_stop
	IM_off
}

ignore_ovlroot()
{
	message "overlayroot will be ignored: $overlayroot"
	overlayroot=
}


# Entry point
debug "$PROG started ($(get_parameter ALTBOOT_LIVEBOOT))"

[ -L /etc/mtab ] ||
	run ln -snf /proc/mounts /etc/mtab
[ -z "$prevdir" ] ||
	prevdir="$(readlink-e "$prevdir")"
[ -n "$prevdir" ] && mountpoint -q -- "$prevdir" ||
	fatal "no previous step results to use with $PROG"
[ -n "$method" ] ||
	method="$(stage2_getenv METHOD)"
profile="${profile:-default}"
timeout="${timeout:-20}"

case "$overlayroot" in
disabled|tmpfs)
	;;
'')
	live_rw=1
	;;
UUID=?*)
	if [ -L "/dev/disk/by-uuid/${overlayroot#UUID=}" ]; then
		live_rw="$(readlink-e "/dev/disk/by-uuid/${overlayroot#UUID=}")"
	else
		ignore_ovlroot
	fi
	;;
LABEL=?*)
	if [ -L "/dev/disk/by-label/${overlayroot#LABEL=}" ]; then
		live_rw="$(readlink-e "/dev/disk/by-label/${overlayroot#LABEL=}")"
	else
		ignore_ovlroot
	fi
	;;
/dev/?*)
	if [ -b "$overlayroot" ]; then
		live_rw="$overlayroot"
	else
		ignore_ovlroot
	fi
	;;
*)
	ignore_ovlroot
	;;
esac

if [ "$overlayroot" = disabled ]; then
	message "rootfs has return back to the read/write mode"
	need_overlay=
elif [ "$overlayroot" = tmpfs ]; then
	message "rootfs switched to the read-only mode, using tmpfs as overlay"
elif [ "$stagename" = rescue ]; then
	message "running rescue"
elif [ "$stagename" = live ]; then
	message "running live"
elif [ -n "$stagename" ] && [ "$flags" != "${flags//*live_ro*/}" ]; then
	message "running live '$stagename'"
	stagename=live
elif [ -n "$overlayroot" ] && [ -b "$live_rw" ]; then
	message "rootfs switched to the read-only mode, using $live_rw as overlay"
	method=
elif grep -qs " $prevdir squashfs " /proc/mounts; then
	message "running unknown rootfs from squashfs"
	live_rw=
else
	message "running unknown rootfs directly"
	need_overlay=
	live_rw=
fi

case "$stagename" in
live|rescue)
	[ -n "$OEM_LIVE_STORAGE" ] && [ -n "$OEM_BAD_STORAGE" ] ||
		live_rw=
	[ "$flags" != "${flags//*live_rw*/}" ] ||
		live_rw=
	;;
esac

if [ -n "$need_overlay" ]; then
	run_in_interactive
else
	passthru_results
fi

debug "$PROG finished"
