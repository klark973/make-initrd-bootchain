#!/bin/bash -efu

. bootchain-sh-functions

bcretry="${bcretry:-1}"
stepnum="${stepnum:-0}"
chainsteps="${chainsteps-}"
prevdir="${prevdir-}"
BC_IM_supported=


debug()
{
	[ -z "$BC_DEBUG" ] ||
		message "$*"
}


if has_module interactive; then
	. interactive-sh-functions

	[ "x${1-}" != "x--foreground" ] ||
		IM_activate "$BC_FGVT_ACTIVATE" "$BC_LOGFILE"
	BC_IM_supported=1
fi

rc=0
while [ -n "$chainsteps" ]; do
	name="${chainsteps%%,*}"
	exe="$handlerdir/$name"

	if [ "$name" = fg ]; then
		[ -n "$BC_IM_supported" ] ||
			fatal "bootchain-interactive feature required"
		assign "callnum" "\${callnum_$name:-0}"
		chainsteps="${chainsteps#$name}"
		chainsteps="${chainsteps#,}"

		if IM_is_active; then
			message "[$callnum] Step '$name' has ignored"
		else
			message "[$callnum] Switching to foreground"

			callnum=$((1 + $callnum))
			assign "callnum_$name" "\$callnum"

			export stepnum chainsteps callnum_fg prevdir bcretry

			IM_exec "$0" --foreground
		fi

	elif [ "$name" = noop ]; then
		chainsteps="${chainsteps#$name}"
		chainsteps="${chainsteps#,}"
		prevdir=
		message "[0] Step '$name' has been passed"

	elif [ "$name" = retry ]; then
		chainsteps="${chainsteps#$name}"
		chainsteps="${chainsteps#,}"
		bcretry=1
		message "subsequent steps will restart after failure"

	elif [ "$name" = noretry ]; then
		chainsteps="${chainsteps#$name}"
		chainsteps="${chainsteps#,}"
		bcretry=0
		message "daemon will be stopped immediately after any step failure"

	elif [ -x "$exe" ]; then
		assign "callnum" "\${callnum_$name:-0}"
		datadir="$mntdir/src/step$stepnum"
		destdir="$mntdir/dst/step$stepnum"

		run mkdir -p -- "$datadir" "$destdir"

		if mountpoint -q -- "$destdir" ||
			[ -s "$destdir/DEVNAME" ] ||
			[ -b "$destdir/dev" ] ||
			[ -c "$destdir/dev" ]
		then
			message "[$callnum] Handler: $exe skipped"
		else
			message "[$callnum] Handler: $exe"

			export name callnum datadir destdir prevdir

			for try in 1 2 3 4 5; do
				[ -z "$BC_DEBUG" ] ||
					run "$handlerdir/debug" ||:
				rc=0
				run "$exe" ||
					rc=$?
				[ "$rc" != 0 ] ||
					break
				[ "$rc" != 2 ] || [ -z "$pipeline_mode" ] ||
					break 2
				message "[$callnum] Handler failed (rc=$rc, try=$try)"
				[ ! -f "$BC_PASSED/$PROG" ] ||
					break 2
				[ "$bcretry" != 0 ] ||
					break
				sleep 2
			done

			[ -r "$BC_NEXTCHAIN" ] ||
				run touch "$BC_PASSED/$name"
			[ ! -f "$BC_PASSED/$PROG" ] ||
				break
			[ "$rc" = 0 ] ||
				break
		fi

		if [ ! -r "$BC_NEXTCHAIN" ]; then
			callnum=$((1 + $callnum))
			assign "callnum_$name" "\$callnum"
			eval "export callnum_$name"
		fi

		stepnum=$((1 + $stepnum))
		prevdir="$(readlink-e "$destdir" 2>/dev/null ||:)"
	fi

	if [ ! -r "$BC_NEXTCHAIN" ]; then
		chainsteps="${chainsteps#$name}"
		chainsteps="${chainsteps#,}"
	else
		debug "chain will be reloaded by $BC_NEXTCHAIN:"
		fdump "$BC_NEXTCHAIN"
		. "$BC_NEXTCHAIN"
		run rm -f -- "$BC_NEXTCHAIN"
	fi

	debug "remaining steps: $chainsteps"
done

[ -z "$chainsteps" ] ||
	message "remaining steps after breaking loop: $chainsteps"

if [ "$rc" = 2 ] && [ -n "$pipeline_mode" ]; then
	debug "finishing in pipeline mode"
elif [ "$rc" = 0 ] && [ -f "$BC_PASSED/$PROG" ]; then
	debug "finishing in bootchain mode"
else
	fatal "daemon terminated incorrectly (rc=$rc)"
fi

if [ -z "$BC_DEBUG" ]; then
	grep -qs " $mntdir/" /proc/mounts ||
		run umount -- "$mntdir" &&
		run rm -rf -- "$mntdir" ||:
else
	prevdir="$(readlink-e "$destdir" 2>/dev/null ||:)"
	[ "$prevdir" = "$rootmnt" ] && datadir="" ||
		datadir="$rootmnt"
	destdir=
	callnum=0
	name=STAGE2

	message "[$callnum] Handler: $handlerdir/debug"

	export name callnum datadir destdir prevdir

	run "$handlerdir/debug" ||:
	debug "last step finished with exit code $rc"

	if [ -f "$BC_LOGFILE" ]; then
		if [ -d "$rootmnt/var/log" ]; then
			run cp -Lf -- "$BC_LOGFILE" "$rootmnt/var/log/"
		else
			run cp -Lf -- "$BC_LOGFILE" "$mntdir/"
		fi
	fi
fi
